/* 
 * DO NOT EDIT: The following content was generated by the template file:
 *    ti/platforms/emt3200LP/templates/Board_init.c.xdt
 */
#include <stdint.h>
#include <stdbool.h>

#include <xdc/std.h>
#include <xdc/runtime/Error.h>
#include <xdc/runtime/System.h>

#include <ti/sysbios/family/arm/m3/Hwi.h>

#include <inc/hw_ints.h>
#include <inc/hw_memmap.h>
#include <inc/hw_types.h>
//#include <inc/hw_gpio.h>

#include <driverlib/pin.h>
#include <driverlib/prcm.h>
#include <driverlib/udma.h>
#include <driverlib/gpio.h>

#include "Board.h"

#if defined(__TI_COMPILER_VERSION__)
#pragma DATA_ALIGN(Board_DMAControlTable, 1024)
#elif defined(__IAR_SYSTEMS_ICC__)
#pragma data_alignment=1024
#elif defined(__GNUC__)
__attribute__ ((aligned (1024)))
#endif
static tDMAControlTable Board_DMAControlTable[32];
static bool DMA_initialized = false;

/* Hwi_Struct used in the initDMA Hwi_construct call */
static Hwi_Struct hwiStruct;

/*
 *  ======== Board_errorDMAHwi ========
 */
static Void Board_errorDMAHwi(UArg arg)
{
    System_printf("DMA error code: %d\n", uDMAErrorStatusGet());
    uDMAErrorStatusClear();
    System_abort("DMA error!!");
}

/*
 *  ======== Board_initDMA ========
 */
void Board_initDMA(void)
{
    Error_Block eb;
    Hwi_Params  hwiParams;

    if (!DMA_initialized) {
        Error_init(&eb);
        Hwi_Params_init(&hwiParams);
        Hwi_construct(&(hwiStruct), INT_UDMAERR, Board_errorDMAHwi,
                      &hwiParams, &eb);
        if (Error_check(&eb)) {
            System_abort("Couldn't create DMA error hwi");
        }

        PRCMPeripheralClkEnable(PRCM_UDMA, PRCM_RUN_MODE_CLK);
        PRCMPeripheralReset(PRCM_UDMA);
        uDMAEnable();
        uDMAControlBaseSet(Board_DMAControlTable);

        DMA_initialized = true;
    }
}

/*
 *  ======== Board_initGeneral ========
 */
void Board_initGeneral(void)
{
    /*  Reset DMA + other essential peripheral initialization
     *  ASSUMED by the simplelink and driverlib libraries
     */
    PRCMCC3200MCUInit();

    /* Configure pins as specified in the current configuration */

    /*
     * ======== Enable Peripheral Clocks ========
     * Enable all clocks (because wiring can use any pin for in any mode
     * at runtime)
     */
    PRCMPeripheralClkEnable(PRCM_CAMERA, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_GPIOA0, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_GPIOA1, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_GPIOA2, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_GPIOA3, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_GSPI, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_I2CA0, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_I2S, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_SDHOST, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_TIMERA0, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_TIMERA1, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_TIMERA2, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_TIMERA3, PRCM_RUN_MODE_CLK);

    PRCMPeripheralClkEnable(PRCM_UARTA0, PRCM_RUN_MODE_CLK);
    PRCMPeripheralClkEnable(PRCM_UARTA1, PRCM_RUN_MODE_CLK);

    /* ======== GPIO Pin Configuration ======== */

    /*
     * Configure LaunchPad P1.2 for Output
     *     device pin: 58 (GPIO3)
     *     Wiring id : 2
     */
    PinTypeGPIO(PIN_58, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA0_BASE, 0x8, GPIO_DIR_MODE_OUT);

    /*
     * Configure LaunchPad P1.3 for Input: LaunchPad SW3 on P1.3
     *     device pin: 4 (GPIO13)
     *     Wiring id : 3
     */
    PinTypeGPIO(PIN_04, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA1_BASE, 0x20, GPIO_DIR_MODE_IN);

    /*
     * Configure LaunchPad P1.6 for Output
     *     device pin: 59 (GPIO4)
     *     Wiring id : 6
     */
    PinTypeGPIO(PIN_59, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA0_BASE, 0x10, GPIO_DIR_MODE_OUT);

    /*
     * Configure LaunchPad P1.9 for Output
     *     device pin: 1 (GPIO10)
     *     Wiring id : 9
     */
    PinTypeGPIO(PIN_01, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA1_BASE, 0x4, GPIO_DIR_MODE_OUT);

    /*
     * Configure LaunchPad P1.10 for Output
     *     device pin: 2 (GPIO11)
     *     Wiring id : 10
     */
    PinTypeGPIO(PIN_02, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA1_BASE, 0x8, GPIO_DIR_MODE_OUT);

    /*
     * Configure LaunchPad P2.10 for Input: LaunchPad SW2 button on P2.10
     *     device pin: 15 (GPIO22)
     *     Wiring id : 11
     */
    PinTypeGPIO(PIN_15, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA2_BASE, 0x40, GPIO_DIR_MODE_IN);

    /*
     * Configure LaunchPad P3.9 for Output: Red LED_D7
     *     device pin: 64 (GPIO9)
     *     Wiring id : 29
     */
    PinTypeGPIO(PIN_64, PIN_MODE_0, false);
    GPIODirModeSet(GPIOA1_BASE, 0x2, GPIO_DIR_MODE_OUT);


    /* ======== UART Pin Configuration ======== */

    /*
     * Configure LaunchPad P2.9 as a UART: UART TX (via USB port)
     *     device pin: 55 (UART0_TX)
     *     Wiring id : 12
     */
    PinTypeUART(PIN_55, PIN_MODE_3);

    /*
     * Configure LaunchPad P3.3 as a UART: UART RX (via USB port)
     *     device pin: 57 (UART0_RX)
     *     Wiring id : 23
     */
    PinTypeUART(PIN_57, PIN_MODE_3);


    /* ======== SPI Pin Configuration ======== */

    /*
     * Configure LaunchPad P1.7 as a SPI pin: SPI CLK
     *     device pin: 5 (GSPI_CLK)
     *     Wiring id : 7
     */
    PinTypeSPI(PIN_05, PIN_MODE_7);

    /*
     * Configure LaunchPad P2.6 as a SPI pin: SPI MOSI
     *     device pin: 7 (GSPI_MOSI)
     *     Wiring id : 15
     */
    PinTypeSPI(PIN_07, PIN_MODE_7);
}

/*
 * ======== GPIO driver ========
 * 
 * The CC3200 LaunchPad has 2 switches, and 3 LEDs available connected
 * to GPIO pins:
 *                                   name  device  connector  wire
 *     SW2 (right/bot) connected to GPIO22   15      P2.10     11
 *     SW3 (left/bot)  connected to GPIO13    4      P1.3       3
 *     LED_D5 (green)  connected to GPIO11    2      P1.10     10
 *     LED_D6 (yellow) connected to GPIO10    1      P1.9       9
 *     LED_D7 (red)    connected to GPIO09   64      P3.9      29
 *
 * Other LEDs and switches (not connected to GPIO pins)
 *
 *     SW1 (right/top) RESET button
 *     LED_D1 (yellow) nRESET (glows if device is functional; not reset)
 *     LED_D2 (green)  Debug  (glows if debug is enabled)
 *     LED_D4 (red)    Power  (glows when 3.3V power is supplied to board)
 *
 * For a raw launchpad the config table would be:
 *     static const GPIO_HWAttrs gpioHWAttrs[Board_GPIOCOUNT] = {
 *         {GPIOA1_BASE, GPIO_PIN_1, GPIO_OUTPUT}, // Board_LED_D7
 *         {GPIOA1_BASE, GPIO_PIN_2, GPIO_OUTPUT}, // Board_LED_D6
 *         {GPIOA1_BASE, GPIO_PIN_3, GPIO_OUTPUT}, // Board_LED_D5
 *         {GPIOA2_BASE, GPIO_PIN_6, GPIO_INPUT},  // Board_SW2
 *         {GPIOA1_BASE, GPIO_PIN_5, GPIO_INPUT},  // Board_SW3
 *         {GPIOA1_BASE, GPIO_PIN_4, GPIO_INPUT},  // Board_MPU9150
 *     };
 */
#include <ti/drivers/GPIO.h>
#include <driverlib/gpio.h>

/* GPIO configuration structure definitions */
const GPIO_HWAttrs gpioHWAttrs[] = {
    {GPIOA0_BASE, GPIO_PIN_0, GPIO_INPUT},  /* GPIO 00 */
    {GPIOA0_BASE, GPIO_PIN_1, GPIO_INPUT},  /* GPIO 01 */
    {GPIOA0_BASE, GPIO_PIN_2, GPIO_INPUT},  /* GPIO 02 */
    {GPIOA0_BASE, GPIO_PIN_3, GPIO_INPUT},  /* GPIO 03 */
    {GPIOA0_BASE, GPIO_PIN_4, GPIO_INPUT},  /* GPIO 04 */
    {GPIOA0_BASE, GPIO_PIN_5, GPIO_INPUT},  /* GPIO 05 */
    {GPIOA0_BASE, GPIO_PIN_6, GPIO_INPUT},  /* GPIO 06 */
    {GPIOA0_BASE, GPIO_PIN_7, GPIO_INPUT},  /* GPIO 07 */

    {GPIOA1_BASE, GPIO_PIN_0, GPIO_INPUT},  /* GPIO 08 */
    {GPIOA1_BASE, GPIO_PIN_1, GPIO_OUTPUT}, /* GPIO 09 (LED_D7) */
    {GPIOA1_BASE, GPIO_PIN_2, GPIO_OUTPUT}, /* GPIO 10 (LED_D6) */
    {GPIOA1_BASE, GPIO_PIN_3, GPIO_OUTPUT}, /* GPIO 11 (LED_D5) */
    {GPIOA1_BASE, GPIO_PIN_4, GPIO_INPUT},  /* GPIO 12 */
    {GPIOA1_BASE, GPIO_PIN_5, GPIO_INPUT},  /* GPIO 13 (SW3) */
    {GPIOA1_BASE, GPIO_PIN_6, GPIO_INPUT},  /* GPIO 14 */
    {GPIOA1_BASE, GPIO_PIN_7, GPIO_INPUT},  /* GPIO 15 */

    {GPIOA2_BASE, GPIO_PIN_0, GPIO_INPUT},  /* GPIO 16 */
    {GPIOA2_BASE, GPIO_PIN_1, GPIO_INPUT},  /* GPIO 17 */
    {GPIOA2_BASE, GPIO_PIN_2, GPIO_INPUT},  /* GPIO 18 (NC) */
    {GPIOA2_BASE, GPIO_PIN_3, GPIO_INPUT},  /* GPIO 19 (NC) */
    {GPIOA2_BASE, GPIO_PIN_4, GPIO_INPUT},  /* GPIO 20 (NC) */
    {GPIOA2_BASE, GPIO_PIN_5, GPIO_INPUT},  /* GPIO 21 (NC) */
    {GPIOA2_BASE, GPIO_PIN_6, GPIO_INPUT},  /* GPIO 22 (SW2) */
    {GPIOA2_BASE, GPIO_PIN_7, GPIO_INPUT},  /* GPIO 23 */

    {GPIOA3_BASE, GPIO_PIN_0, GPIO_INPUT},  /* GPIO 24 */
    {GPIOA3_BASE, GPIO_PIN_1, GPIO_INPUT},  /* GPIO 25 */
    {GPIOA3_BASE, GPIO_PIN_2, GPIO_INPUT},  /* GPIO 26 (NC) */
    {GPIOA3_BASE, GPIO_PIN_3, GPIO_INPUT},  /* GPIO 27 (NC) */
    {GPIOA3_BASE, GPIO_PIN_4, GPIO_INPUT},  /* GPIO 28 */
    {GPIOA3_BASE, GPIO_PIN_5, GPIO_INPUT},  /* GPIO 29 (NC) */
    {GPIOA3_BASE, GPIO_PIN_6, GPIO_INPUT},  /* GPIO 30 */
    {GPIOA3_BASE, GPIO_PIN_7, GPIO_INPUT}   /* GPIO 31 */
};

const GPIO_Config GPIO_config[] = {
    {&gpioHWAttrs[0]},
    {&gpioHWAttrs[1]},
    {&gpioHWAttrs[2]},
    {&gpioHWAttrs[3]},
    {&gpioHWAttrs[4]},
    {&gpioHWAttrs[5]},
    {&gpioHWAttrs[6]},
    {&gpioHWAttrs[7]},
    {&gpioHWAttrs[8]},
    {&gpioHWAttrs[9]},
    {&gpioHWAttrs[10]},
    {&gpioHWAttrs[11]},
    {&gpioHWAttrs[12]},
    {&gpioHWAttrs[13]},
    {&gpioHWAttrs[14]},
    {&gpioHWAttrs[15]},
    {&gpioHWAttrs[16]},
    {&gpioHWAttrs[17]},
    {&gpioHWAttrs[18]},
    {&gpioHWAttrs[19]},
    {&gpioHWAttrs[20]},
    {&gpioHWAttrs[21]},
    {&gpioHWAttrs[22]},
    {&gpioHWAttrs[23]},
    {&gpioHWAttrs[24]},
    {&gpioHWAttrs[25]},
    {&gpioHWAttrs[26]},
    {&gpioHWAttrs[27]},
    {&gpioHWAttrs[28]},
    {&gpioHWAttrs[29]},
    {&gpioHWAttrs[30]},
    {&gpioHWAttrs[31]},
    {NULL}
};

/* User requested callback functions for the GPIO input signals */

/* GPIO callback structure for Port A0 GPIO interrupts */
static Hwi_Struct callbackHwi0; /* memory to construct the Hwi object for port 0 */
GPIO_Callbacks Board_gpioCallbacks0 = {
    GPIOA0_BASE,     /* GPIO port A0 */
    INT_GPIOA0,      /* port A0 interrupt number */
    &callbackHwi0,   /* Pointer to a family-specific Hwi_Struct */
    {
        NULL,        /* bit 0 (GPIO0) Board_GPIO0 callback */
        NULL,        /* bit 1 (GPIO1) Board_GPIO1 callback */
        NULL,        /* bit 2 (GPIO2) Board_GPIO2 callback */
        NULL,        /* bit 3 (GPIO3) Board_GPIO3 callback */
        NULL,        /* bit 4 (GPIO4) Board_GPIO4 callback */
        NULL,        /* bit 5 (GPIO5) Board_GPIO5 callback */
        NULL,        /* bit 6 (GPIO6) Board_GPIO6 callback */
        NULL,        /* bit 7 (GPIO7) Board_GPIO7 callback */
    }
};

/* GPIO callback structure for Port A1 GPIO interrupts */
static Hwi_Struct callbackHwi1; /* memory to construct the Hwi object for port 1 */
GPIO_Callbacks Board_gpioCallbacks1 = {
    GPIOA1_BASE,     /* GPIO port A1 */
    INT_GPIOA1,      /* port A1 interrupt number */
    &callbackHwi1,   /* Pointer to a family-specific Hwi_Struct */
    {
        NULL,        /* bit 0 (GPIO8) Board_GPIO8 callback */
        NULL,        /* bit 1 (GPIO9) Board_LED_RED callback */
        NULL,        /* bit 2 (GPIO10) Board_GPIO10 callback */
        NULL,        /* bit 3 (GPIO11) Board_GPIO11 callback */
        NULL,        /* bit 4 (GPIO12) Board_MPU9150_INT callback */
        NULL,        /* bit 5 (GPIO13) Board_BUTTON1 callback */
        NULL,        /* bit 6 (GPIO14) Board_GPIO14 callback */
        NULL,        /* bit 7 (GPIO15) Board_GPIO15 callback */
    }
};

/* GPIO callback structure for Port A2 GPIO interrupts */
static Hwi_Struct callbackHwi2; /* memory to construct the Hwi object for port 2 */
GPIO_Callbacks Board_gpioCallbacks2 = {
    GPIOA2_BASE,     /* GPIO port A2 */
    INT_GPIOA2,      /* port A2 interrupt number */
    &callbackHwi2,   /* Pointer to a family-specific Hwi_Struct */
    {
        NULL,        /* bit 0 (GPIO16) Board_GPIO16 callback */
        NULL,        /* bit 1 (GPIO17) Board_GPIO17 callback */
        NULL,        /* bit 2 (GPIO18)  */
        NULL,        /* bit 3 (GPIO19)  */
        NULL,        /* bit 4 (GPIO20)  */
        NULL,        /* bit 5 (GPIO21)  */
        NULL,        /* bit 6 (GPIO22) Board_BUTTON0 callback */
        NULL,        /* bit 7 (GPIO23) Board_GPIO23 callback */
    }
};

/* GPIO callback structure for Port A3 GPIO interrupts */
static Hwi_Struct callbackHwi3; /* memory to construct the Hwi object for port 3 */
GPIO_Callbacks Board_gpioCallbacks3 = {
    GPIOA3_BASE,     /* GPIO port A3 */
    INT_GPIOA3,      /* port A3 interrupt number */
    &callbackHwi3,   /* Pointer to a family-specific Hwi_Struct */
    {
        NULL,        /* bit 0 (GPIO24) Board_GPIO24 callback */
        NULL,        /* bit 1 (GPIO25) Board_GPIO25 callback */
        NULL,        /* bit 2 (GPIO26)  */
        NULL,        /* bit 3 (GPIO27)  */
        NULL,        /* bit 4 (GPIO28) Board_GPIO28 callback */
        NULL,        /* bit 5 (GPIO29)  */
        NULL,        /* bit 6 (GPIO30) Board_GPIO30 callback */
        NULL,        /* bit 7 (GPIO31) Board_GPIO31 callback */
    }
};

/*
 *  ======== Board_initGPIO ========
 */
void Board_initGPIO(void)
{
    /* Once GPIO_init is called, GPIO_config cannot be changed */
    GPIO_init();
}

/*
 * ======== I2C ========
 */
#include <ti/drivers/I2C.h>
#include <ti/drivers/i2c/I2CCC3200.h>
#include <driverlib/i2c.h>

I2CCC3200_Object i2cCC3200Objects[Board_I2CCOUNT];

/* I2C configuration structure */
const I2CCC3200_HWAttrs i2cCC3200HWAttrs[Board_I2CCOUNT] = {
    {I2CA0_BASE, INT_I2CA0}
};

const I2C_Config I2C_config[] = {
    {&I2CCC3200_fxnTable, &i2cCC3200Objects[0], &i2cCC3200HWAttrs[0]},
    {NULL, NULL, NULL}
};

/*
 *  ======== Board_initI2C ========
 */
void Board_initI2C(void)
{
    I2C_init();
}

/*
 * ======== PWM driver ========
 */
#include <ti/drivers/PWM.h>
#include <ti/drivers/pwm/PWMTimerCC3200.h>
#include <driverlib/timer.h>

PWMTimerCC3200_Object pwmCC3200Objects[Board_PWMCOUNT];

const PWMTimerCC3200_HWAttrs pwmCC3200HWAttrs[Board_PWMCOUNT] = {
    {TIMERA0_BASE, TIMER_A},
    {TIMERA0_BASE, TIMER_B},
    {TIMERA1_BASE, TIMER_A},
    {TIMERA1_BASE, TIMER_B},
    {TIMERA2_BASE, TIMER_A},
    {TIMERA2_BASE, TIMER_B},
    {TIMERA3_BASE, TIMER_A},
    {TIMERA3_BASE, TIMER_B}
};

const PWM_Config PWM_config[] = {
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[0], &pwmCC3200HWAttrs[0]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[1], &pwmCC3200HWAttrs[1]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[2], &pwmCC3200HWAttrs[2]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[3], &pwmCC3200HWAttrs[3]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[4], &pwmCC3200HWAttrs[4]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[5], &pwmCC3200HWAttrs[5]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[6], &pwmCC3200HWAttrs[6]},
    {&PWMTimerCC3200_fxnTable, &pwmCC3200Objects[7], &pwmCC3200HWAttrs[7]},
    {NULL, NULL, NULL}
};

/*
 *  ======== Board_initPWM ========
 */
void Board_initPWM(void)
{
    PWM_init();
}

/*
 * ======== SPI driver ========
 */
#include <ti/drivers/SPI.h>
#include <ti/drivers/spi/SPICC3200DMA.h>
#include <ti/drivers/power/PowerCC3200.h>
#include <driverlib/spi.h>

static SPICC3200DMA_Object SPICC3200DMAobjects[Board_SPICOUNT];

#if defined(__TI_COMPILER_VERSION__)
#pragma DATA_ALIGN(spiCC3200DMAscratchBuf, 32)
#elif defined(__IAR_SYSTEMS_ICC__)
#pragma data_alignment=32
#elif defined(__GNUC__)
__attribute__ ((aligned (32)))
#endif
static uint32_t spiCC3200DMAscratchBuf[Board_SPICOUNT];

/* SPI configuration structure */
static const SPICC3200DMA_HWAttrs SPICC3200DMAHWAttrs[Board_SPICOUNT] = {
    {
        GSPI_BASE,
        INT_GSPI,
        PowerCC3200_PERIPH_GSPI,
        PRCM_GSPI,
        SPI_HW_CTRL_CS,
        SPI_CS_ACTIVELOW,
        SPI_4PIN_MODE,
        SPI_TURBO_OFF,
        &spiCC3200DMAscratchBuf[0],
        0,
        UDMA_CH6_GSPI_RX,
        UDMA_CH7_GSPI_TX,
    },
};

const SPI_Config SPI_config[] = {
    {&SPICC3200DMA_fxnTable, &SPICC3200DMAobjects[0], &SPICC3200DMAHWAttrs[0]},
    {NULL, NULL, NULL},
};

/*
 *  ======== Board_initSPI ========
 */
void Board_initSPI(void)
{
    Board_initDMA();
    SPI_init();
}

/*
 * ======== UART driver ========
 */
#include <ti/drivers/UART.h>
#include <ti/drivers/uart/UARTCC3200.h>

UARTCC3200_Object uartCC3200Objects[Board_UARTCOUNT];

/* UART configuration structure */
const UARTCC3200_HWAttrs uartCC3200HWAttrs[Board_UARTCOUNT] = {
    {UARTA0_BASE, INT_UARTA0},
};

const UART_Config UART_config[] = {
    {
        &UARTCC3200_fxnTable,
        &uartCC3200Objects[0],
        &uartCC3200HWAttrs[0]
    },
    {NULL, NULL, NULL}
};

/*
 *  ======== Board_initUART ========
 */
void Board_initUART(void)
{
    UART_init();
}

#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <ti/sysbios/interfaces/IHwi.h>

/*
 *  ======== Board_init ========
 *  Initialialize the ti.platforms.tink2 hardware
 */
void Board_init(void)
{
    PWM_Params params;

    /* driver-independent initialization */
    Board_initGeneral();

    /* initialize the DMA so that _all_ SPI transfers use DMA (including
     * the internal drivers for the WiFi and serial flash)
     */
    Board_initDMA(); 

    /* driver-specific initialization */
    Board_initGPIO();
    Board_initI2C();
    Board_initPWM();
    Board_initSPI();
    Board_initUART();

    /* Create PWM instances */
    PWM_Params_init(&params);

    params.period = 2040; /* arduino period is 2.04ms (490Hz) */
    params.dutyMode = PWM_DUTY_COUNTS;

    PWM_open(Board_PWM0, &params);
    PWM_open(Board_PWM1, &params);
    PWM_open(Board_PWM2, &params);
    PWM_open(Board_PWM3, &params);
    PWM_open(Board_PWM4, &params);
    PWM_open(Board_PWM5, &params);
    PWM_open(Board_PWM6, &params);
    PWM_open(Board_PWM7, &params);

    /* setup callbacks for all GPIO ports used */
    GPIO_setupCallbacks(&Board_gpioCallbacks0);
    GPIO_setupCallbacks(&Board_gpioCallbacks1);
    GPIO_setupCallbacks(&Board_gpioCallbacks2);
    GPIO_setupCallbacks(&Board_gpioCallbacks3);

    __extern void Wiring_GPIO_hwiIntFxn(UArg callbacks);
  
    /* hijack the common hwi func to point to Wiring's handler that clears the GPIO interrupt */
    Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks0.hwiStruct), (IHwi_FuncPtr)Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks0);
    Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks1.hwiStruct), (IHwi_FuncPtr)Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks1);
    Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks2.hwiStruct), (IHwi_FuncPtr)Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks2);
    Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks3.hwiStruct), (IHwi_FuncPtr)Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks3);
}
